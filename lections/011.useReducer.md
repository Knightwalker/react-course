### react:hooks:useReducer
`useReducer` is a build-in React hook that allows you manage complex state in a predictable and controlled way than `useState`. It works by taking a reducer function and an initial state value, and returns a state object and a dispatch function. The state object represents the current state of the initial state value, and the dispatch function is used to trigger updates to the state. 

Instead of directly modifying the state object with `setState`, as you would with `useState`, you pass an action object to the dispatch function. The reducer function then takes in the current state and the action object, and returns a new state object based on the action type. This provides more control over the state updates, and encapsulates the complexity of managing complex state.

It's important to note that the reducer function should be a pure function, meaning that it should not modify the current state object directly. Instead, it should always return a new object that represents the new state. This is because React internally compares the old state object with the new state object to determine if there is a change. If there is a change, React will re-render the component to reflect the new state, otherwise it will not.

In summary, `useReducer` is a powerful hook for managing complex state in a more predictable and controlled way, by encapsulating the state updates in a reducer function and action objects. It provides more control over the state updates, and can improve performance by reducing unnecessary re-renders.

**Mechanism:**
1. The `dispatch` function is called with the action object, triggering the execution of the reducer function.
2. The reducer function takes in the current state and the action object as arguments, and returns a new state object based on the action type. 
- The reducer function should be a pure function, meaning that it should not modify the current state object directly. Instead, it should always return a new object that represents the new state. This is because internally React will `shallow` compare the old state object with the new state object in order to determine if there is a change. If there is a change it will re-render, otherwise it will not. While technically we can mutate the object directly only at the top-level and React will recognize the change, we canâ€™t mutate nested objects, because the changes will not be detected and a change will not be applied, which is a bug. This is why we must always create a new object, which will change the reference in memory and signal React that there is a change. We can use either the spread syntax or the `Object.assign()` method to create this new object and update the fields we want. `Object.assign()` method is preferred for when we work with nested state objects, because it creates a deep copy of the state object, meaning that any nested objects will also be copied and not simply referenced.
3. React compares the new state object with the previous state object to determine if any changes have occurred. This is done using a process called "reconciliation". React uses a diffing algorithm to compare the virtual DOM of the component before and after the state change. This allows React to detect any changes in the component and update the actual DOM accordingly.
    - After the reducer function returns a new state object, React creates a new virtual DOM tree that represents the updated state. This virtual tree is a lightweight copy of the actual DOM, and it contains all the elements and attributes of the component.
    - React then compares this new virtual DOM tree with the previous virtual DOM tree using a diffing algorithm. The diffing algorithm calculates the differences between the two virtual trees and determines the minimum set of changes needed to update the actual DOM. The diffing algorithm works by recursively comparing each node in the virtual DOM tree. If a node has changed, React updates the corresponding node in the actual DOM. If a node is added or removed, React creates or removes the corresponding node in the actual DOM.
    - To optimize performance, React tries to minimize the number of changes needed to update the actual DOM. It does this by comparing nodes in the virtual DOM tree from top to bottom and left to right. This ensures that changes are grouped together as much as possible, reducing the number of updates needed.
    - Once the minimal set of changes has been determined, React updates the actual DOM to reflect the new state of the component. This update is done in a single batch to minimize the number of DOM manipulations and improve performance. During this process, React also applies any necessary CSS changes or other layout updates that may be required.
4. If there are any changes in the state, React schedules a re-render of the component using the ReactDOM.render() method. The re-render is scheduled asynchronously and does not happen immediately. Instead, React batches multiple state updates together and updates the component in one go to improve performance.
5. During the re-render, React updates the virtual DOM to reflect the new state. The virtual DOM is a lightweight copy of the actual DOM, and it contains all the elements and attributes of the component. React updates the virtual DOM by applying the state changes to the component's elements and attributes.
